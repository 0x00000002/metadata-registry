// SPDX-License-Identifier: MIT

pragma solidity 0.8.24;

import "../Swappable.sol";
import "../src/ProcessedTokens.sol";
import "../src/NFT.sol";
import "../src/SFT.sol";
import "../src/NFTProxyMinter.sol";
import "../src/SFTProxyMinter.sol";
import "./AccessManagedRoles.sol";
import "../src/utils/Errors.sol";

import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/access/manager/AccessManager.sol";
import "@openzeppelin/contracts/access/manager/AccessManaged.sol";
import "@openzeppelin/contracts/access/manager/IAccessManaged.sol";
import {IERC721Errors} from "@openzeppelin/contracts/interfaces/draft-IERC6093.sol";
import "@openzeppelin/lib/forge-std/src/Test.sol";
import "forge-std/console.sol";
import "forge-std/Vm.sol";

string constant tokenURI = "https://meta.futureverse.com/traits/partybears/porcini_{id}.json";

address constant user = 0xA847d497b38B9e11833EAc3ea03921B40e6d847c;
address constant admin = 0x1Fb0E85b7Ba55F0384d0E06D81DF915aeb3baca3;
address constant manager = 0x1Fb0E85b7Ba55F0384d0E06D81DF915aeb3baca3;
address constant signer = 0xaebC048B4D219D6822C17F1fe06E36Eba67D4144;

bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;

uint256 constant SRC_TOKEN_1 = 2525;
uint256 constant SRC_TOKEN_2 = 3636;
uint256 constant SRC_TOKEN_3 = 5555;
uint256 constant SRC_TOKEN_4 = 900001;

uint256 constant NFT_ID_1 = 7824;
uint256 constant NFT_ID_2 = 123456;

uint256 constant SWORD_ID = 1623;
uint256 constant HELMET_ID = 5690;
uint256 constant RING_ID = 234567;
uint256 constant GOLD_ID = 9990;
uint256 constant SILVER_ID = 9991;
uint256 constant ERC20_ID = 9999;

uint256 constant AMOUNT_TO_MINT_SEQUENTIALLY = 10;

/**
 * @dev Tests for the ASM The Next Legend - Character contract
 */
contract SwappableTest is Test, Errors {
    bytes4 ACCESS_ERROR =
        IAccessControl.AccessControlUnauthorizedAccount.selector;

    Swappable s_;
    ProcessedTokens t_;
    AccessManager m_;
    NFT src_;
    NFT nft_;
    SFT sft_;
    NFTProxyMinter np_;
    SFTProxyMinter sp_;

    uint256[] ids;
    uint256[] values;

    address deployer = address(this);
    address minter;
    address acc;

    bytes BatchByContract1;
    bytes BatchByContract2;
    bytes BatchByContract3;
    bytes BatchByContract4;

    bytes payload1;
    bytes payload2;
    bytes payload3;
    bytes payload4;

    bytes signature1;
    bytes signature2;
    bytes signature3;
    bytes signature4;

    bool isTrue;
    uint32 delay;

    event BytesEvent(bytes hash);
    event Bytes32Event(bytes32 hash);
    event SignerUpdated(address indexed manager, address newSigner);
    event Separated(
        address indexed to,
        address indexed nftAddress,
        uint256 indexed nftId,
        address transferTo
    );

    /** ----------------------------------
     * ! Setup
     * ----------------------------------- */

    // The state of the contract gets reset before each
    // test is run, with the `setUp()` function being called
    // each time after deployment. Think of this like a JavaScript
    // `beforeEach` block
    function setUp() public {
        setupContracts();
        setupAccessManager();
        encodePayloads();
        getSignatures();
    }

    function setupContracts() internal {
        m_ = new AccessManager(admin);
        t_ = new ProcessedTokens(address(m_));
        s_ = new Swappable(address(m_), signer, address(t_));
        minter = address(s_);

        src_ = new NFT("SRC", "SRC", manager);

        nft_ = new NFT("NFT", "NFT", manager);
        sft_ = new SFT(manager, tokenURI);

        np_ = new NFTProxyMinter(manager, minter, address(nft_));
        sp_ = new SFTProxyMinter(manager, minter, address(sft_));

        vm.startPrank(manager);

        src_.grantRole(MINTER, minter);
        nft_.grantRole(MINTER, address(np_));
        sft_.grantRole(MINTER, address(sp_));
        np_.grantRole(MINTER, minter);
        sp_.grantRole(MINTER, minter);
        vm.stopPrank();

        ids = new uint256[](3);
        values = new uint256[](3);
        ids[0] = SRC_TOKEN_1;
        ids[1] = SRC_TOKEN_2;
        ids[2] = SRC_TOKEN_3;
        values[0] = 0;
        values[1] = 0;
        values[2] = 0;

        vm.prank(minter);
        src_.mintBatch(user, ids, values);
        delete ids;
        delete values;

        ids = new uint256[](1);
        values = new uint256[](1);
        ids[0] = SRC_TOKEN_4;
        values[0] = 0;

        vm.prank(minter);
        src_.mintBatch(manager, ids, values);
        delete ids;
        delete values;
    }

    function setupAccessManager() internal {
        bytes4[] memory selectors = new bytes4[](1);

        vm.startPrank(admin);
        // setup public role for Swappable's `separate` function
        selectors[0] = s_.separate.selector;
        m_.setTargetFunctionRole(address(s_), selectors, PUBLIC_ROLE);

        // setup manager role for Swappable's `setSigner` function
        selectors[0] = s_.setSigner.selector;
        m_.setTargetFunctionRole(manager, selectors, MANAGER_ROLE);
        m_.grantRole(MANAGER_ROLE, manager, 0);

        selectors[0] = t_.set.selector;
        m_.setTargetFunctionRole(address(t_), selectors, WRITER_ROLE);
        m_.grantRole(WRITER_ROLE, address(s_), 0);

        uint64 ptSetRole = m_.getTargetFunctionRole(
            address(t_),
            t_.set.selector
        );

        assertEq(ptSetRole, WRITER_ROLE);
        (isTrue, delay) = m_.hasRole(WRITER_ROLE, address(s_));
        assert(isTrue);
        assertEq(delay, 0);

        bool isPaused = m_.isTargetClosed(address(s_));
        assert(!isPaused);

        isPaused = m_.isTargetClosed(address(t_));
        assert(!isPaused);

        (isTrue, delay) = m_.hasRole(WRITER_ROLE, address(s_));
        assert(isTrue);

        (isTrue, delay) = m_.hasRole(MANAGER_ROLE, manager);
        assert(isTrue);

        (isTrue, delay) = m_.hasRole(PUBLIC_ROLE, user);
        assert(isTrue);

        vm.stopPrank();
    }

    function encodePayloads() internal {
        // *******************************************
        // NFT + SFTs tokens set, original token burnt
        // *******************************************

        Swappable.BatchByContract[]
            memory bbc = new Swappable.BatchByContract[](2);

        ids = new uint256[](2);
        values = new uint256[](2);

        ids[0] = NFT_ID_1;
        ids[1] = NFT_ID_2;

        values[0] = 0;
        values[1] = 1000000;

        bbc[0] = Swappable.BatchByContract(
            address(np_),
            IMintable.Batch(ids, values)
        );

        ids = new uint256[](5);
        values = new uint256[](5);

        ids[0] = SWORD_ID;
        ids[1] = RING_ID;
        ids[2] = GOLD_ID;
        ids[3] = SILVER_ID;
        ids[4] = ERC20_ID;

        values[0] = 1;
        values[1] = 1;
        values[2] = 1;
        values[3] = 100;
        values[4] = 100e18;

        bbc[1] = Swappable.BatchByContract(
            address(sp_),
            IMintable.Batch(ids, values)
        );

        BatchByContract1 = abi.encode(bbc);

        // Payload: receiver, original token address, transferTo, BatchByContract
        payload1 = abi.encode(src_, SRC_TOKEN_1, address(1), BatchByContract1);

        delete bbc; // cleanup
        delete ids; // cleanup
        delete values; // cleanup

        // ****************************************************
        // Sequential NFTs, lock original token (owned by receiver)
        // ****************************************************

        bbc = new Swappable.BatchByContract[](1);
        ids = new uint256[](1);
        values = new uint256[](1);

        ids[0] = 0;
        values[0] = AMOUNT_TO_MINT_SEQUENTIALLY;

        bbc[0] = Swappable.BatchByContract(
            address(np_),
            IMintable.Batch(ids, values)
        );
        BatchByContract2 = abi.encode(bbc);
        payload2 = abi.encode(
            src_,
            SRC_TOKEN_2,
            address(this),
            BatchByContract2
        );

        delete bbc; // cleanup
        delete ids; // cleanup
        delete values; // cleanup

        // ****************************************************
        // 1 NFT, do nothing with original token
        // ****************************************************

        bbc = new Swappable.BatchByContract[](1);
        ids = new uint256[](1);
        values = new uint256[](1);

        ids[0] = 0;
        values[0] = 1;

        bbc[0] = Swappable.BatchByContract(
            address(np_),
            IMintable.Batch(ids, values)
        );
        BatchByContract3 = abi.encode(bbc);
        payload3 = abi.encode(src_, SRC_TOKEN_3, address(0), BatchByContract3);

        delete bbc; // cleanup
        delete ids; // cleanup
        delete values; // cleanup

        // ****************************************************
        // Sequential NFTs, lock original token (owned by caller)
        // ****************************************************

        bbc = new Swappable.BatchByContract[](1);
        ids = new uint256[](1);
        values = new uint256[](1);

        ids[0] = 0;
        values[0] = AMOUNT_TO_MINT_SEQUENTIALLY;

        bbc[0] = Swappable.BatchByContract(
            address(np_),
            IMintable.Batch(ids, values)
        );
        BatchByContract4 = abi.encode(bbc);
        payload4 = abi.encode(
            src_,
            SRC_TOKEN_4,
            address(this),
            BatchByContract4
        );

        delete bbc; // cleanup
        delete ids; // cleanup
        delete values; // cleanup
    }

    function getSignatures() internal {
        uint256 signerPK = vm.envUint("DEV_SIGNER_PRIVATE_KEY");

        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32",
                _getMessageHash(payload1)
            )
        );

        // console.log("hash1:", Strings.toHexString(uint256(h1), 32));

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPK, digest);

        signature1 = abi.encodePacked(r, s, v);

        digest = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32",
                _getMessageHash(payload2)
            )
        );
        (v, r, s) = vm.sign(signerPK, digest);
        signature2 = abi.encodePacked(r, s, v);

        digest = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32",
                _getMessageHash(payload3)
            )
        );
        (v, r, s) = vm.sign(signerPK, digest);
        signature3 = abi.encodePacked(r, s, v);

        digest = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32",
                _getMessageHash(payload4)
            )
        );
        (v, r, s) = vm.sign(signerPK, digest);
        signature4 = abi.encodePacked(r, s, v);
    }

    /** ----------------------------------
     * ! Testing contracts states (preparation)
     * ----------------------------------- */

    function test_contracts_states() public skipTest(false) {
        bytes4 iERC721 = type(IERC721).interfaceId;
        bytes4 iAccessControl = type(AccessControl).interfaceId;
        bytes4 iERC165 = type(IERC165).interfaceId;
        bytes4 iMintable = type(IMintable).interfaceId;

        bool supportsIERC721;
        bool supportsIERC165;
        bool supportsIAccessControl;
        bool supportsIMintable;

        assert(src_.ownerOf(SRC_TOKEN_1) == user);
        assert(src_.ownerOf(SRC_TOKEN_2) == user);

        // Swappable states
        assert(s_.getSigner() == signer);

        assertFalse(m_.isTargetClosed(address(s_)));

        assertEq(
            m_.getTargetFunctionRole(address(s_), s_.separate.selector),
            PUBLIC_ROLE
        );

        assertFalse(
            m_.getTargetFunctionRole(address(s_), s_.setSigner.selector) ==
                PUBLIC_ROLE
        );

        (isTrue, delay) = m_.hasRole(PUBLIC_ROLE, user);

        assert(isTrue);

        (isTrue, delay) = m_.canCall(user, address(s_), s_.separate.selector);
        assert(delay == 0);
        assert(isTrue);

        (isTrue, delay) = m_.canCall(user, address(s_), s_.setSigner.selector);
        assert(!isTrue);
        assert(delay == 0);

        // SRC states
        supportsIERC721 = src_.supportsInterface(iERC721);
        supportsIERC165 = src_.supportsInterface(iERC165);
        supportsIAccessControl = src_.supportsInterface(iAccessControl);
        supportsIMintable = src_.supportsInterface(iMintable);
        assertTrue(supportsIERC721, "Should support IERC721 interface");
        assertTrue(supportsIERC165, "Should support IERC165 interface");
        assertTrue(supportsIAccessControl, "Should support IAccessControl");
        assertTrue(supportsIMintable, "Should support IMintable");
        assert(src_.hasRole(MANAGER, manager));
        assert(src_.hasRole(DEFAULT_ADMIN_ROLE, manager));
    }

    function test_BatchByContract_structure() public skipTest(false) {
        Swappable.BatchByContract[] memory l = abi.decode(
            BatchByContract1,
            (Swappable.BatchByContract[])
        );

        assertEq(l[0].contractAddress, address(np_));
        assertEq(l[0].batch.ids[0], NFT_ID_1);
        assertEq(l[0].batch.ids[1], NFT_ID_2);
        assertEq(l[0].batch.values[0], 0);
        assertEq(l[0].batch.values[1], 1000000);

        assertEq(l[1].contractAddress, address(sp_));
        assertEq(l[1].batch.ids[0], SWORD_ID);
        assertEq(l[1].batch.ids[1], RING_ID);
        assertEq(l[1].batch.ids[2], GOLD_ID);
        assertEq(l[1].batch.ids[3], SILVER_ID);
        assertEq(l[1].batch.ids[4], ERC20_ID);

        IMintable s = IMintable(address(sft_));
        bool res = s.supportsInterface(type(IMintable).interfaceId);
        assert(res == true);

        IMintable n = IMintable(address(nft_));
        res = n.supportsInterface(type(IMintable).interfaceId);
        assert(res == true);
    }

    function test_verify_signatures_are_correct() public view skipTest(false) {
        bool isVerified = _verify(payload1, signature1);

        // testing local verification function
        assert(isVerified == true);
        isVerified = _verify(payload2, signature2);
        assert(isVerified == true);
        isVerified = _verify(payload3, signature3);
        assert(isVerified == true);

        // testing contract's verification function
        isVerified = s_.validateSignature(payload1, signature1);
        assert(isVerified == true);
        isVerified = s_.validateSignature(payload2, signature2);
        assert(isVerified == true);
        isVerified = s_.validateSignature(payload3, signature3);
        assert(isVerified == true);
    }

    /** ----------------------------------
     * ! Business logic Tests
     * ----------------------------------- */

    function test_mint_paused_contract() public skipTest(false) {
        /** -------------------------------------------------------
         * @notice Paused contract
         * --------------------------------------------------------
         * @notice GIVEN: target (Swappable) is closed
         * @notice  THEN: error is thrown
         */

        vm.startPrank(manager);
        m_.setTargetClosed(address(s_), true);
        assert(m_.isTargetClosed(address(s_)));

        vm.expectRevert(
            abi.encodeWithSelector(
                IAccessManaged.AccessManagedUnauthorized.selector,
                manager
            )
        );
        s_.separate(deployer, payload1, signature1);
    }

    function test_mint_wrong_user() public skipTest(false) {
        /** -------------------------------------------------------
         * @notice Wrong user specified
         * --------------------------------------------------------
         * @notice GIVEN: address different from encoded in payload
         * @notice  THEN: error InvalidSignature is thrown
         */

        assertEq(nft_.balanceOf(user), 0, "Should be 0");

        vm.expectRevert(
            abi.encodeWithSelector(
                IERC721Errors.ERC721NonexistentToken.selector,
                NFT_ID_1
            )
        );

        nft_.ownerOf(NFT_ID_1);

        vm.expectRevert(
            abi.encodeWithSelector(MintingError.selector, WRONG_TOKEN_OWNER)
        );
        s_.separate(deployer, payload1, signature1);
    }

    function test_mint_used_payload() public skipTest(false) {
        /** -------------------------------------------------------
         * @notice Should not allow to mint with the same payload twice
         * --------------------------------------------------------
         * @notice GIVEN: the same payload
         * @notice  THEN: error
         */

        (isTrue, delay) = m_.hasRole(WRITER_ROLE, address(s_));
        assertEq(isTrue, true);
        assertEq(delay, 0);

        (isTrue, delay) = m_.canCall(address(s_), address(t_), t_.set.selector);
        assertEq(isTrue, true);
        assertEq(delay, 0);

        vm.startPrank(user);
        src_.approve(address(s_), SRC_TOKEN_2);
        s_.separate(user, payload2, signature2);

        vm.expectRevert(
            abi.encodeWithSelector(MintingError.selector, WRONG_TOKEN_OWNER)
        );
        // SRC_TOKEN_2 already locked (and separated)
        s_.separate(user, payload2, signature2);

        src_.approve(address(s_), SRC_TOKEN_3);
        s_.separate(user, payload3, signature3);
        // nothing was done with SRC_TOKEN_3, so it should pass ownership check
        // but not the separation check
        vm.expectRevert(
            abi.encodeWithSelector(MintingError.selector, ALREADY_SEPARATED)
        );
        s_.separate(user, payload3, signature3);
    }

    function test_mint_happyPath_burn() public skipTest(false) {
        /** --------------------------------------------------------------------
         * @notice Happy path 1: NFT + SFTs tokens minted, original token burnt
         * ---------------------------------------------------------------------
         * @notice GIVEN: valid address, valid signature, valid encoded data
         * @notice  THEN: new tokens are minted
         * @notice   AND: receiver's token balance is updated for NFT and SFTs
         * @notice   AND: event Separated(receiver, srcContract, srcTokenID, nonce) is emitted
         * @notice   AND: original token is burnt
         * ---------------------------------------------------------------------
         */

        uint256 srcBalance = src_.balanceOf(user);
        assertEq(srcBalance, 3, "Should be 3");
        assertEq(nft_.balanceOf(user), 0, "Should be 0");
        vm.expectRevert(
            abi.encodeWithSelector(
                IERC721Errors.ERC721NonexistentToken.selector,
                NFT_ID_1
            )
        );
        nft_.ownerOf(NFT_ID_1); // token does not exist

        vm.prank(minter);
        vm.expectEmit(true, true, true, true);
        emit Separated(user, address(src_), SRC_TOKEN_1, address(1));
        s_.separate(user, payload1, signature1);

        assertEq(src_.balanceOf(user), srcBalance - 1, "Should decrease");
        uint256 nftBalance = nft_.balanceOf(user);
        assertEq(nftBalance, 2, "Should be 2 NFTs");
        assertEq(nft_.ownerOf(NFT_ID_1), user, "Should belong to user");
        assertEq(nft_.ownerOf(NFT_ID_2), user, "Should belong to user");
        assertEq(sft_.balanceOf(user, SWORD_ID), 1, "Should be 1");
        assertEq(sft_.balanceOf(user, RING_ID), 1, "Should be 1");
        assertEq(sft_.balanceOf(user, GOLD_ID), 1, "Should be 1");
        assertEq(sft_.balanceOf(user, SILVER_ID), 100, "Should be 100");
        assertEq(sft_.balanceOf(user, ERC20_ID), 100e18, "Should be 100e18");
    }

    function test_mint_happyPath_transfer() public skipTest(false) {
        uint256 nftBalance = nft_.balanceOf(user);

        /** --------------------------------------------------------------------------------------
         * @notice Happy path 2: sequential NFT minting, original token belongs to receiver
         * ---------------------------------------------------------------------------------------
         * @notice GIVEN: valid address, valid signature, valid encoded data
         * @notice   AND: token owner is a receiver
         * @notice  THEN: new tokens are minted
         * @notice   AND: receiver's token balance is updated for NFT
         * @notice   AND: event Separated(receiver, srcContract, srcTokenID, nonce) is emitted
         * @notice   AND: original token is transferred to this contract (locked)
         * ---------------------------------------------------------------------------------------
         */

        assert(src_.ownerOf(SRC_TOKEN_2) == user);

        vm.startPrank(user);
        src_.approve(address(s_), SRC_TOKEN_2);

        vm.expectEmit(true, true, true, true);
        emit Separated(user, address(src_), SRC_TOKEN_2, address(this));
        s_.separate(user, payload2, signature2);

        assert(src_.ownerOf(SRC_TOKEN_2) == address(this)); // token is locked
        assertEq(
            nft_.balanceOf(user),
            nftBalance + AMOUNT_TO_MINT_SEQUENTIALLY,
            "NEW NFTs are minted"
        );

        /** --------------------------------------------------------------------------------------
         * @notice Happy path 2: sequential NFT minting, original token belongs to caller
         * ---------------------------------------------------------------------------------------
         * @notice GIVEN: valid address, valid signature, valid encoded data
         * @notice   AND: token owner is a function caller
         * @notice  THEN: new tokens are minted
         * @notice   AND: receiver's token balance is updated for NFT
         * @notice   AND: event Separated(receiver, srcContract, srcTokenID, nonce) is emitted
         * @notice   AND: original token is transferred to this contract (locked)
         * ---------------------------------------------------------------------------------------
         */

        assert(src_.ownerOf(SRC_TOKEN_4) == manager);
        nftBalance = nft_.balanceOf(user);

        vm.startPrank(manager);
        src_.approve(address(s_), SRC_TOKEN_4);

        vm.expectEmit(true, true, true, true);
        emit Separated(user, address(src_), SRC_TOKEN_4, address(this));
        s_.separate(user, payload4, signature4);

        assert(src_.ownerOf(SRC_TOKEN_4) == address(this)); // token is locked
        assertEq(
            nft_.balanceOf(user),
            nftBalance + AMOUNT_TO_MINT_SEQUENTIALLY,
            "NEW NFTs are minted"
        );
    }

    function test_mint_zeroAddressReceiver() public skipTest(false) {
        /** -------------------------------------------------------
         * @notice Invalid input
         * --------------------------------------------------------
         * @notice GIVEN: zero address
         * @notice  THEN: revert with InvalidInput error
         */
        vm.prank(minter);
        vm.expectRevert(
            abi.encodeWithSelector(InvalidInput.selector, INVALID_ADDRESS)
        );
        s_.separate(address(0), payload1, signature1);
    }

    function test_admin_setSigner() public skipTest(false) {
        /** -------------------------------------------------------
         * @notice Call from wrong account
         * --------------------------------------------------------
         * @notice GIVEN: non-zero address
         * @notice  WHEN: called by user other than Manager
         * @notice  THEN: revert with AccessControl error
         */
        vm.prank(user);
        vm.expectRevert(
            abi.encodeWithSelector(
                IAccessManaged.AccessManagedUnauthorized.selector,
                user
            )
        );
        s_.setSigner(user);

        /** -------------------------------------------------------
         * @notice Happy path
         * --------------------------------------------------------
         * @notice GIVEN: non-zero address
         * @notice  WHEN: called by Manager
         * @notice  THEN: the address has been stored as a Signer
         */
        vm.startPrank(manager);
        vm.expectEmit(true, true, true, true);
        emit SignerUpdated(manager, user);

        s_.setSigner(user);
        assert(s_.getSigner() == user);
    }

    /** ----------------------------------
     * ! Helpers for this contract
     * ----------------------------------- */

    function _recoverSigner(
        bytes32 ethSignedMessageHash,
        bytes memory signature
    ) private pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = _splitSignature(signature);

        return ecrecover(ethSignedMessageHash, v, r, s);
    }

    function _getEthSignedMessageHash(
        bytes32 messageHash
    ) private pure returns (bytes32) {
        /*
        Signature is produced by signing a keccak256 hash with the following format:
        "\x19Ethereum Signed Message\n" + len(msg) + msg
        */
        return
            keccak256(
                abi.encodePacked(
                    "\x19Ethereum Signed Message:\n32",
                    messageHash
                )
            );
    }

    function _splitSignature(
        bytes memory sig
    ) private pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(sig.length == 65, "invalid signature length");

        assembly {
            /*
            First 32 bytes stores the length of the signature

            add(sig, 32) = pointer of sig + 32
            effectively, skips first 32 bytes of signature

            mload(p) loads next 32 bytes starting at the memory address p into memory
            */

            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }
        // implicitly return (r, s, v)
    }

    function _getMessageHash(bytes memory data) private pure returns (bytes32) {
        return keccak256(abi.encode(data));
    }

    function _verify(
        bytes memory data,
        bytes memory signature
    ) private pure returns (bool) {
        bytes32 messageHash = _getMessageHash(data);
        bytes32 ethSignedMessageHash = _getEthSignedMessageHash(messageHash);
        address signer_ = _recoverSigner(ethSignedMessageHash, signature);
        // console.log("signer:", signer_);
        return signer_ == signer;
    }

    /** ----------------------------------
     * ! Test contract modifiers
     * ----------------------------------- */

    /**
     * @notice this modifier will skip the test
     */
    modifier skipTest(bool isSkipped) {
        if (!isSkipped) {
            _;
        }
    }

    /**
     * @notice this modifier will skip the testFail*** tests ONLY
     */
    modifier skipFailing(bool isSkipped) {
        if (isSkipped) {
            require(0 == 1);
        } else {
            _;
        }
    }
}
